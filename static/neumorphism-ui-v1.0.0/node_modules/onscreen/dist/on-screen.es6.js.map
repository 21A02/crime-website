{"version":3,"file":null,"sources":["../lib/methods/attach.js","../lib/helpers/in-viewport.js","../lib/helpers/in-container.js","../lib/helpers/scroll-handler.js","../lib/methods/debounced-scroll.js","../lib/methods/destroy.js","../lib/methods/off.js","../lib/methods/on.js","../lib/helpers/observe-dom.js","../lib/index.js"],"sourcesContent":["/**\n * Attaches the scroll event handler\n *\n * @return {void}\n */\nfunction attach() {\n    const container = this.options.container;\n\n    if (container instanceof HTMLElement) {\n        const style = window.getComputedStyle(container);\n\n        if (style.position === 'static') {\n            container.style.position = 'relative';\n        }\n    }\n\n    container.addEventListener('scroll', this._scroll, { passive: true });\n    window.addEventListener('resize', this._scroll, { passive: true });\n    this._scroll();\n    this.attached = true;\n}\n\nexport default attach;\n","/**\n * Checks an element's position in respect to the viewport\n * and determines wether it's inside the viewport.\n *\n * @param {node} element The DOM node you want to check\n * @return {boolean} A boolean value that indicates wether is on or off the viewport.\n */\nfunction inViewport(el, options = { tolerance: 0 }) {\n    if (!el) {\n        throw new Error('You should specify the element you want to test');\n    }\n\n    if (typeof el === 'string') {\n        el = document.querySelector(el);\n    }\n\n    const elRect = el.getBoundingClientRect();\n\n    return (\n        // Check bottom boundary\n        elRect.bottom - options.tolerance > 0 &&\n\n        // Check right boundary\n        elRect.right - options.tolerance > 0 &&\n\n        // Check left boundary\n        elRect.left + options.tolerance < (window.innerWidth ||\n        document.documentElement.clientWidth) &&\n\n        // Check top boundary\n        elRect.top + options.tolerance < (window.innerHeight ||\n        document.documentElement.clientHeight)\n    );\n}\n\nexport default inViewport;\n","/**\n * Checks an element's position in respect to a HTMLElement\n * and determines wether it's within its boundaries.\n *\n * @param {node} element The DOM node you want to check\n * @return {boolean} A boolean value that indicates wether is on or off the container.\n */\nfunction inContainer(el, options = { tolerance: 0, container: '' }) {\n    if (!el) {\n        throw new Error('You should specify the element you want to test');\n    }\n\n    if (typeof el === 'string') {\n        el = document.querySelector(el);\n    }\n    if (typeof options === 'string') {\n        options = {\n            tolerance: 0,\n            container: document.querySelector(options)\n        };\n    }\n    if (typeof options.container === 'string') {\n        options.container = document.querySelector(options.container);\n    }\n    if (options instanceof HTMLElement) {\n        options = {\n            tolerance: 0,\n            container: options\n        };\n    }\n    if (!options.container) {\n        throw new Error('You should specify a container element');\n    }\n\n    const containerRect = options.container.getBoundingClientRect();\n\n    return (\n        // // Check bottom boundary\n        (el.offsetTop + el.clientHeight) - options.tolerance >\n        options.container.scrollTop &&\n\n        // Check right boundary\n        (el.offsetLeft + el.clientWidth) - options.tolerance >\n        options.container.scrollLeft &&\n\n        // Check left boundary\n        el.offsetLeft + options.tolerance <\n        containerRect.width + options.container.scrollLeft &&\n\n        // // Check top boundary\n        el.offsetTop + options.tolerance <\n        containerRect.height + options.container.scrollTop\n    );\n}\n\nexport default inContainer;\n","import inViewport from './in-viewport';\nimport inContainer from './in-container';\n\n// TODO: Refactor this so it can be easily tested\n/* istanbul ignore next */\nfunction eventHandler(trackedElements = {}, options = { tolerance: 0 }) {\n    const selectors = Object.keys(trackedElements);\n    let testVisibility;\n\n    if (!selectors.length) return;\n\n    if (options.container === window) {\n        testVisibility = inViewport;\n    } else {\n        testVisibility = inContainer;\n    }\n\n    selectors.forEach((selector) => {\n        trackedElements[selector].nodes.forEach((item) => {\n            if (testVisibility(item.node, options)) {\n                item.wasVisible = item.isVisible;\n                item.isVisible = true;\n            } else {\n                item.wasVisible = item.isVisible;\n                item.isVisible = false;\n            }\n            if (item.isVisible === true && item.wasVisible === false) {\n                if (!trackedElements[selector].enter) return;\n\n                Object.keys(trackedElements[selector].enter).forEach((callback) => {\n                    if (typeof trackedElements[selector].enter[callback] === 'function') {\n                        trackedElements[selector].enter[callback](item.node, 'enter');\n                    }\n                });\n            }\n            if (item.isVisible === false && item.wasVisible === true) {\n                if (!trackedElements[selector].leave) return;\n\n                Object.keys(trackedElements[selector].leave).forEach((callback) => {\n                    if (typeof trackedElements[selector].leave[callback] === 'function') {\n                        trackedElements[selector].leave[callback](item.node, 'leave');\n                    }\n                });\n            }\n        });\n    });\n}\n\nexport default eventHandler;\n","import scrollHandler from '../helpers/scroll-handler';\n\n/**\n * Debounces the scroll event to avoid performance issues\n *\n * @return {void}\n */\nfunction debouncedScroll() {\n    let timeout;\n\n    return () => {\n        clearTimeout(timeout);\n\n        timeout = setTimeout(() => {\n            scrollHandler(this.trackedElements, this.options);\n        }, this.options.debounce);\n    };\n}\n\nexport default debouncedScroll;\n","/**\n * Removes the scroll event handler\n *\n * @return {void}\n */\nfunction destroy() {\n    this.options.container.removeEventListener('scroll', this._scroll);\n    window.removeEventListener('resize', this._scroll);\n    this.attached = false;\n}\n\nexport default destroy;\n","/**\n * Stops tracking elements matching a CSS selector. If a selector has no\n * callbacks it gets removed.\n *\n * @param {string} event The event you want to stop tracking (enter or leave)\n * @param {string} selector The CSS selector you want to stop tracking\n * @return {void}\n */\nfunction off(event, selector, handler) {\n    const enterCallbacks = Object.keys(this.trackedElements[selector].enter || {});\n    const leaveCallbacks = Object.keys(this.trackedElements[selector].leave || {});\n\n    if ({}.hasOwnProperty.call(this.trackedElements, selector)) {\n        if (handler) {\n            if (this.trackedElements[selector][event]) {\n                const callbackName = (typeof handler === 'function') ? handler.name : handler;\n                delete this.trackedElements[selector][event][callbackName];\n            }\n        } else {\n            delete this.trackedElements[selector][event];\n        }\n    }\n\n    if (!enterCallbacks.length && !leaveCallbacks.length) {\n        delete this.trackedElements[selector];\n    }\n}\n\nexport default off;\n","/**\n * Starts tracking elements matching a CSS selector\n *\n * @param {string} event The event you want to track (enter or leave)\n * @param {string} selector The element you want to track\n * @param {function} callback The callback function to handle the event\n * @return {void}\n */\nfunction on(event, selector, callback) {\n    const allowed = ['enter', 'leave'];\n\n    if (!event) throw new Error('No event given. Choose either enter or leave');\n    if (!selector) throw new Error('No selector to track');\n    if (allowed.indexOf(event) < 0) throw new Error(`${event} event is not supported`);\n\n    if (!{}.hasOwnProperty.call(this.trackedElements, selector)) {\n        this.trackedElements[selector] = {};\n    }\n\n    this.trackedElements[selector].nodes = [];\n\n    for (let i = 0, elems = document.querySelectorAll(selector); i < elems.length; i++) {\n        const item = {\n            isVisible: false,\n            wasVisible: false,\n            node: elems[i]\n        };\n\n        this.trackedElements[selector].nodes.push(item);\n    }\n\n    if (typeof callback === 'function') {\n        if (!this.trackedElements[selector][event]) {\n            this.trackedElements[selector][event] = {};\n        }\n\n        this.trackedElements[selector][event][(callback.name || 'anonymous')] = callback;\n    }\n}\n\nexport default on;\n","/**\n * Observes DOM mutations and runs a callback function when\n * detecting one.\n *\n * @param {node} obj The DOM node you want to observe\n * @param {function} callback The callback function you want to call\n * @return {void}\n */\nfunction observeDOM(obj, callback) {\n    const MutationObserver = window.MutationObserver || window.WebKitMutationObserver;\n\n    /* istanbul ignore else */\n    if (MutationObserver) {\n        const obs = new MutationObserver(callback);\n\n        obs.observe(obj, {\n            childList: true,\n            subtree: true\n        });\n    } else {\n        obj.addEventListener('DOMNodeInserted', callback, false);\n        obj.addEventListener('DOMNodeRemoved', callback, false);\n    }\n}\n\nexport default observeDOM;\n","// Methods\nimport attach from './methods/attach';\nimport debouncedScroll from './methods/debounced-scroll';\nimport destroy from './methods/destroy';\nimport off from './methods/off';\nimport on from './methods/on';\n\n// Helpers\nimport observeDOM from './helpers/observe-dom';\nimport inViewport from './helpers/in-viewport';\n\n/**\n * Detects wether DOM nodes enter or leave the viewport\n *\n * @constructor\n * @param {object} options The configuration object\n */\nfunction OnScreen(options = { tolerance: 0, debounce: 100, container: window }) {\n    this.options = {};\n    this.trackedElements = {};\n\n    Object.defineProperties(this.options, {\n        container: {\n            configurable: false,\n            enumerable: false,\n            get() {\n                let container;\n\n                if (typeof options.container === 'string') {\n                    container = document.querySelector(options.container);\n                } else if (options.container instanceof HTMLElement) {\n                    container = options.container;\n                }\n\n                return container || window;\n            },\n            set(value) {\n                options.container = value;\n            }\n        },\n        debounce: {\n            get() {\n                return parseInt(options.debounce, 10) || 100;\n            },\n            set(value) {\n                options.debounce = value;\n            }\n        },\n        tolerance: {\n            get() {\n                return parseInt(options.tolerance, 10) || 0;\n            },\n            set(value) {\n                options.tolerance = value;\n            }\n        }\n    });\n\n    Object.defineProperty(this, '_scroll', {\n        enumerable: false,\n        configurable: false,\n        writable: false,\n        value: this._debouncedScroll.call(this)\n    });\n\n    observeDOM(document.querySelector('body'), () => {\n        Object.keys(this.trackedElements).forEach((element) => {\n            this.on('enter', element);\n            this.on('leave', element);\n        });\n    });\n\n    this.attach();\n}\n\nObject.defineProperties(OnScreen.prototype, {\n    _debouncedScroll: {\n        configurable: false,\n        writable: false,\n        enumerable: false,\n        value: debouncedScroll\n    },\n    attach: {\n        configurable: false,\n        writable: false,\n        enumerable: false,\n        value: attach\n    },\n    destroy: {\n        configurable: false,\n        writable: false,\n        enumerable: false,\n        value: destroy\n    },\n    off: {\n        configurable: false,\n        writable: false,\n        enumerable: false,\n        value: off\n    },\n    on: {\n        configurable: false,\n        writable: false,\n        enumerable: false,\n        value: on\n    }\n});\n\nOnScreen.check = inViewport;\n\nexport default OnScreen;\n"],"names":["attach","container","options","HTMLElement","style","window","getComputedStyle","position","addEventListener","_scroll","passive","attached","inViewport","el","tolerance","Error","document","querySelector","elRect","getBoundingClientRect","bottom","right","left","innerWidth","documentElement","clientWidth","top","innerHeight","clientHeight","inContainer","containerRect","offsetTop","scrollTop","offsetLeft","scrollLeft","width","height","eventHandler","trackedElements","selectors","Object","keys","testVisibility","length","forEach","selector","nodes","item","node","wasVisible","isVisible","enter","callback","leave","debouncedScroll","timeout","setTimeout","debounce","destroy","removeEventListener","off","event","handler","enterCallbacks","leaveCallbacks","hasOwnProperty","call","callbackName","name","on","allowed","indexOf","i","elems","querySelectorAll","push","observeDOM","obj","MutationObserver","WebKitMutationObserver","obs","observe","OnScreen","defineProperties","value","parseInt","defineProperty","_debouncedScroll","element","prototype","check"],"mappings":"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"}